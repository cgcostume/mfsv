<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>mfsv</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
	</body>

	<script src="js/Three.js"></script>
	<script src="js/OBJLoader.js"></script>
	<script src="js/TrackballControls.js"></script>

	<!-- Shaders -->
	<script type="x-shader/x-vertex" id="vertexShader">
		// switch on high precision floats
		#ifdef GL_ES
		precision highp float;
		#endif
		varying vec3 vNormal;
		void main() {
		    vNormal = normal;
		    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
	</script>

	<script type="x-shader/x-fragment" id="fragmentShader">
		// switch on high precision floats
		#ifdef GL_ES
		precision highp float;
		#endif
		varying vec3 vNormal;
		uniform vec2 resolution;
		uniform sampler2D accumulationBuffer;

		void main() {
		    float dProd = max(0.0, dot(vNormal, normalize(cameraPosition)));
		    gl_FragColor = vec4(dProd, dProd, dProd, 1.0);
				//texture2D(accumulationBuffer, gl_FragCoord.xy / resolution.xy);
				//mix(vec4(dProd, dProd, dProd, 1.0), texture2D(accumulationBuffer, gl_FragCoord.xy), weight);
			}
	</script>

	<script type="text/javascript">

	var mainCamera, controls, mainScene, renderer, mainShaderMaterial, finalShaderMaterial;
	var firstBuffer, secondBuffer, bufferFlipFlop = true, textureQuad;
	var currentFrame, frameCount = 50;

	init();
	animate();

	function init() {
		// hide scrollbars
		document.documentElement.style.overflow = 'hidden';  // firefox, chrome
    document.body.scroll = "no"; // ie only

		// prepare renderer
		var screenWidth = window.innerWidth, screenHeight = window.innerHeight;
		renderer = new THREE.WebGLRenderer( { antialias: false } );
		renderer.setSize(screenWidth, screenHeight);
		renderer.setPixelRatio(window.devicePixelRatio);

		// set up buffers
		var bufferSettings = {
			minFilter: THREE.LinearFilter,
			agFilter: THREE.LinearFilter,
			format: THREE.RGBAFormat,
			type: THREE.FloatType
		};
		firstBuffer = new THREE.WebGLRenderTarget(screenWidth, screenHeight, bufferSettings);
		secondBuffer = new THREE.WebGLRenderTarget(screenWidth, screenHeight, bufferSettings);

		// initialize cameras
		mainCamera = new THREE.PerspectiveCamera(75, screenWidth / screenHeight, 0.1, 2000);
		mainCamera.position.z = 7;
		finalCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

		// prepare scene
		mainScene = new THREE.Scene();
		mainScene.add(mainCamera);
		finalScene = new THREE.Scene();
		finalScene.add(finalCamera);

		// load shaders -- todo: Use RawShaderMaterial
		mainShaderMaterial = new THREE.ShaderMaterial({
			uniforms: {
				cameraPosition: { value: mainCamera.position },
				accumulationBuffer: { type: "t", value: firstBuffer }
			},
			vertexShader:   document.getElementById('vertexShader').textContent,
			fragmentShader: document.getElementById('fragmentShader').textContent
		});

		// load and add teapot to the scene
		var manager = new THREE.LoadingManager();
		manager.onProgress = function ( item, loaded, total ) {
			console.log( item, loaded, total );
		};
		var loader = new THREE.OBJLoader(manager);
		loader.load('obj/teapot.obj', function (object) {
			object.traverse( function ( child ) {
							if ( child instanceof THREE.Mesh ) {
								child.material = mainShaderMaterial;
							}
						} );
			mainScene.add(object);
			render();
		} );

		// load quad for finalScene
		textureQuad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), new THREE.MeshBasicMaterial( { color: 0xffffff } ));
		finalScene.add(textureQuad);

		// configure trackball controls
		controls = new THREE.TrackballControls(mainCamera);
		controls.addEventListener('change', requestRender);
		controls.target.set(0, 0, 0);
		controls.rotateSpeed = 5.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;
		controls.noZoom = false;
		controls.noPan = false;
		controls.staticMoving = true;
		controls.dynamicDampingFactor = 0.3;
		controls.keys = [ 65, 83, 68 ];

		// attach the render-supplied DOM element
		document.body.appendChild(renderer.domElement);
		window.addEventListener('resize', onWindowResize, false);
	}

	function animate() {
		requestAnimationFrame(animate);
		controls.update();
		if (currentFrame < frameCount) {
			currentFrame++;
			render();
		}
	}

	function requestRender() {
		currentFrame = 0;
	}

	function render() {
		console.log("render()");
		mainShaderMaterial.uniforms.accumulationBuffer.value = bufferFlipFlop ? secondBuffer : firstBuffer

		if(bufferFlipFlop)
			renderer.render(mainScene, mainCamera, firstBuffer, true);
		else
			renderer.render(mainScene, mainCamera, secondBuffer, true);

		textureQuad.material.map = !bufferFlipFlop ? secondBuffer : firstBuffer;

		renderer.render(finalScene, finalCamera);

		bufferFlipFlop = !bufferFlipFlop;
	}

	function onWindowResize() {
		var screenWidth = window.innerWidth, screenHeight = window.innerHeight;
		mainCamera.aspect = screenWidth / screenHeight;
		renderer.setSize(screenWidth, screenHeight);
		firstBuffer.setSize(screenWidth, screenHeight);
		secondBuffer.setSize(screenWidth, screenHeight);
		mainCamera.updateProjectionMatrix();
		controls.handleResize();
		render();
	}
	</script>
</html>
